diff --git a/CMakeLists.txt b/CMakeLists.txt
index eab91a8..8c6bbe0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -239,6 +239,10 @@ add_definitions("-D Identity_CHECK=1")
 # add in a billion checks which slow things down but catch bugs.
 add_definitions("-D PARANOIA=1")
 
+if (NOT $ENV{DUMB_CLIENT} STREQUAL "")
+    add_definitions("-D RouterModule_DUMB_CLIENT=1")
+endif ()
+
 include_directories(${CMAKE_SOURCE_DIR})
 
 #if NEON is specified then we will force NACL to use NEON.
diff --git a/dht/dhtcore/RouterModule.c b/dht/dhtcore/RouterModule.c
index af891e5..58482d5 100644
--- a/dht/dhtcore/RouterModule.c
+++ b/dht/dhtcore/RouterModule.c
@@ -402,7 +402,7 @@ static inline int handleQuery(struct DHTMessage* message,
     Dict_putInt(message->asDict, CJDHTConstants_ENC_INDEX, schemeNum, message->allocator);
 
 
-    return (nodeList) ? sendNodes(nodeList, message, module) : 0;
+    return (nodeList && !(RouterModule_DUMB_CLIENT)) ? sendNodes(nodeList, message, module) : 0;
 }
 
 /**
diff --git a/dht/dhtcore/RouterModule.h b/dht/dhtcore/RouterModule.h
index 20ddb8b..d3f8d1e 100644
--- a/dht/dhtcore/RouterModule.h
+++ b/dht/dhtcore/RouterModule.h
@@ -49,6 +49,11 @@ struct RouterModule_Promise
 /** The number of nodes to return in a search query. */
 #define RouterModule_K 8
 
+/** Set this in the compile to make the node a dumb client which will not advertize routes. */
+#ifndef RouterModule_DUMB_CLIENT
+    #define RouterModule_DUMB_CLIENT 0
+#endif
+
 /**
  * Register a new RouterModule.
  *
diff --git a/interface/SessionManager.c b/interface/SessionManager.c
index 8d363a4..90a4ab3 100644
--- a/interface/SessionManager.c
+++ b/interface/SessionManager.c
@@ -14,6 +14,7 @@
  */
 #include "interface/SessionManager.h"
 #include "crypto/CryptoAuth.h"
+#include "crypto/AddressCalc.h"
 #include "interface/Interface.h"
 #include "memory/Allocator.h"
 #include "util/Bits.h"
@@ -83,6 +84,16 @@ static void cleanup(void* vsm)
     }
 }
 
+static void check(struct SessionManager* sm, int mapIndex)
+{
+    uint8_t* herPubKey = CryptoAuth_getHerPublicKey(&sm->ifaceMap.values[mapIndex].iface);
+    if (!Bits_isZero(herPubKey, 32)) {
+        uint8_t ip6[16];
+        AddressCalc_addressForPublicKey(ip6, herPubKey);
+        Assert_always(!Bits_memcmp(&sm->ifaceMap.keys[mapIndex], ip6, 16));
+    }
+}
+
 struct SessionManager_Session* SessionManager_getSession(uint8_t* lookupKey,
                                                          uint8_t cryptoKey[32],
                                                          struct SessionManager* sm)
@@ -132,6 +143,8 @@ struct SessionManager_Session* SessionManager_getSession(uint8_t* lookupKey,
         }
     }
 
+    check(sm, ifaceIndex);
+
     return &sm->ifaceMap.values[ifaceIndex];
 }
 
@@ -139,7 +152,11 @@ struct SessionManager_Session* SessionManager_sessionForHandle(uint32_t handle,
                                                                struct SessionManager* sm)
 {
     int index = Map_OfSessionsByIp6_indexForHandle(handle - FIRST_HANDLE, &sm->ifaceMap);
-    return (index == -1) ? NULL : &sm->ifaceMap.values[index];
+    if (index < 0) {
+        return NULL;
+    }
+    check(sm, index);
+    return &sm->ifaceMap.values[index];
 }
 
 struct SessionManager_HandleList* SessionManager_getHandleList(struct SessionManager* sm,
diff --git a/net/Ducttape.c b/net/Ducttape.c
index 876bbbf..2a2db06 100644
--- a/net/Ducttape.c
+++ b/net/Ducttape.c
@@ -281,8 +281,10 @@ static inline uint8_t incomingForMe(struct Message* message,
                                     uint8_t herPublicKey[32])
 {
     struct Address addr;
-    Bits_memcpyConst(addr.ip6.bytes, session->ip6, 16);
-    //AddressCalc_addressForPublicKey(addr.ip6.bytes, herPubKey);
+    //Bits_memcpyConst(addr.ip6.bytes, session->ip6, 16);
+    Bits_memcpyConst(addr.key, herPublicKey, 32);
+    AddressCalc_addressForPublicKey(addr.ip6.bytes, herPublicKey);
+    Assert_always(!Bits_memcmp(session->ip6, addr.ip6.bytes, 16));
 
     if (Bits_memcmp(addr.ip6.bytes, dtHeader->ip6Header->sourceAddr, 16)) {
         #ifdef Log_DEBUG
@@ -614,12 +616,21 @@ static uint8_t sendToNode(struct Message* message, struct Interface* iface)
 /**
  * Send an arbitrary message to the tun device.
  *
- * @param message to be sent, must be prefixed with IpTunnel_PacketInfoHeader.
+ * @param message to be sent.
  * @param iface an interface for which receiverContext is the ducttape.
  */
 static uint8_t sendToTun(struct Message* message, struct Interface* iface)
 {
     struct Ducttape_pvt* context = Identity_cast((struct Ducttape_pvt*)iface->receiverContext);
+    uint16_t msgType = TUNMessageType_pop(message);
+    if (msgType == Ethernet_TYPE_IP6) {
+        Assert_always(message->length >= Headers_IP6Header_SIZE);
+        struct Headers_IP6Header* header = (struct Headers_IP6Header*) message->bytes;
+        if (header->sourceAddr[0] == 0xfc || header->destinationAddr[0] == 0xfc) {
+            Assert_failure("you can't do that");
+        }
+    }
+    TUNMessageType_push(message, msgType);
     if (context->userIf) {
         return context->userIf->sendMessage(message, context->userIf);
     }
diff --git a/switch/SwitchCore.c b/switch/SwitchCore.c
index c90116d..e942196 100644
--- a/switch/SwitchCore.c
+++ b/switch/SwitchCore.c
@@ -251,9 +251,24 @@ static uint8_t receiveMessage(struct Message* message, struct Interface* iface)
                sourceIndex, destIndex, label, targetLabel);
     */
 
-    const uint16_t err = sendMessage(&core->interfaces[destIndex], message, sourceIf->core->logger);
-    if (err) {
+    int cloneLength = (message->length < Control_Error_MAX_SIZE) ?
+        message->length : Control_Error_MAX_SIZE;
+    uint8_t messageClone[Control_Error_MAX_SIZE];
+    Bits_memcpy(messageClone, message->bytes, cloneLength);
+
+     const uint16_t err =
+         sendMessage(&core->interfaces[destIndex], message, sourceIf->core->logger);
+     if (err) {
         Log_debug(sourceIf->core->logger, "Sending packet caused an error. err=%u", err);
+
+        // be careful, the message could have decrypted content in it
+        // and we don't want to spill it out over the wire.
+        message->length = message->capacity;
+        Message_shift(message, -message->length);
+        Message_shift(message, Control_Error_MAX_SIZE);
+        Bits_memcpy(message->bytes, messageClone, cloneLength);
+        message->length = cloneLength;
+        header = (struct Headers_SwitchHeader*) message->bytes;
         header->label_be = Endian_bigEndianToHost64(label);
         sendError(sourceIf, message, err, sourceIf->core->logger);
         return Error_NONE;
diff --git a/tunnel/IpTunnel.c b/tunnel/IpTunnel.c
index e91b229..502a35f 100644
--- a/tunnel/IpTunnel.c
+++ b/tunnel/IpTunnel.c
@@ -534,7 +534,14 @@ static struct IpTunnel_Connection* getConnection(struct IpTunnel_Connection* con
 {
     uint8_t* source = (sourceAndDestIp6) ? sourceAndDestIp6 : sourceAndDestIp4;
     uint32_t length = (sourceAndDestIp6) ? 16 : 4;
-    #define DESTINATION source + length
+    uint8_t* destination = source + length;
+
+    if (sourceAndDestIp6) {
+        // never allowed
+        if (source[0] == 0xfc || destination[0] == 0xfc) {
+            return NULL;
+        }
+    }
 
     struct IpTunnel_Connection* lastConnection =
         &context->pub.connectionList.connections[context->pub.connectionList.count];
@@ -549,8 +556,8 @@ static struct IpTunnel_Connection* getConnection(struct IpTunnel_Connection* con
         // connections are first on the list.
         //
         uint8_t* compareAddr = (isFromTun)
-            ? ((conn->isOutgoing) ? source : DESTINATION)
-            : ((conn->isOutgoing) ? DESTINATION : source);
+            ? ((conn->isOutgoing) ? source : destination)
+            : ((conn->isOutgoing) ? destination : source);
 
         uint8_t* connectionAddr = (sourceAndDestIp6) ? conn->connectionIp6 : conn->connectionIp4;
         if (!Bits_memcmp(compareAddr, connectionAddr, length)) {
